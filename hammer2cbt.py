# Used for headers
ch_used_str = [""] * 241
ch_used_str[48] = "Noise channel"
ch_used_str[192] = "Duty channel 2"
ch_used_str[240] = "Duty channel 2 & Noise channel"

# Frequency table
CH2freqs = [44,156,262,363,457,547,631,710,786,854,923,986,1046,1102,1155,1205,1253,1297,1339,1379,1417,1452,1486,1517,1546,1575,1602,1627,1650,1673,1694,1714,1732,1750,1767,1783,1798,1812,1825,1837,1849,1860,1871,1881,1890,1899,1907,1915,1923,1930,1936,1943,1949,1954,1959,1964,1969,1974,1978,1982,1985,1988,1992,1995,1998,2001,2004,2006,2009,2011,2013,2015]

"""
FX HAMMER DATA LOCATIONS:

Header:
SFX Priority:	0x200 + fxnum
CH Used:		0x300 + fxnum (0x30 = CH2 used, 0x03 = CH4 used)

SFX data:		0x400 + (fxnum * 256)
- Frame duration	
- CH2 pan		NR51 format
- CH2 vol		NR22 format
- CH2 duty		NR21 format
- CH2 note		Note = (this - 0x40) / 2
- CH4 pan		NR51 format
- CH4 vol		NR42 format
- CH4 freq		NR43 format

WARNING: FX Hammer pan values are inverted
"""

import argparse
parser = argparse.ArgumentParser()
parser.add_argument("fxsav", help="FX Hammer .sav file (Normally called 'hammered.sav').")
parser.add_argument("fxnum", help="Index of the desired SFX to export.")
parser.add_argument("out", help="Folder where .c and .h files will be saved.")
parser.add_argument("--fxammo", help="Number of SFX to export (starts at fxnum, ends at fxnum + fxammo)")
parser.add_argument("--fxinv", help="invert pan values for SFX (FX Hammer has them inverted by default, without this flag, the panning will be corrected)", action="store_true")

args = parser.parse_args()

fxsav = open(args.fxsav,"rb")

loop = 1
if args.fxammo:
	loop = int(args.fxammo)
for n in range(int(args.fxnum), int(args.fxnum) + loop):
	fxnum = n

	# Export header
	fxh_pry = 0		# Export priority
	fxh_chu = 0		# Export CH used
	fxh_len = 0		# Export length

	# Export data
	fxh_buf = []

	def bufadd(b):
		fxh_buf.append(b)

	def fxh_get():
		return int.from_bytes(fxsav.read(1), "big")
	# Taken from some website, ikik
	def swapbits(n, p1, p2):
	    bit1 = (n >> p1) & 1
	    bit2 = (n >> p2) & 1
	    x = (bit1 ^ bit2)
	    x = (x << p1) | (x << p2)
	    result = n ^ x
	    return result

	# Get the priority
	fxsav.seek(0x200 + fxnum)
	fxh_pry = fxh_get()

	# Get channels used
	fxsav.seek(0x300 + fxnum)
	fxh_chu = fxh_get()
	ch = 0 # Temp value to make my life easier
	if fxh_chu & 0x30: # If CH2
		ch |= 12
	if fxh_chu & 0x03: # If CH4
		ch |= 3
	fxh_chu = ch << 4
	# This basically converts the 0x33 based FX Hammer mask value into a 0b11110000 value, the higher 2 enabled bits mean CH2, the bottom mean CH4

	if fxh_chu == 0: # If no channels are used, the sfx is empty, abort
		sys.exit("ERROR: SFX #" + (("{0:X}").format(fxnum)).zfill(2) + " is empty, aborting conversion.")

	# Get all data (Length)
	fxsav.seek(0x400 + (fxnum * 256))

	# Loop through every frame
	for f in range(32):
		temp_buf = [0] * 8 # The curr frame's data goes here, then converted to CBTFX format
		temp_buf[0] = fxh_get() # Get frame length
		if temp_buf[0] != 0: # if the frame isn't the last frame
			temp_buf[1] = fxh_get()	# CH2 pan
			temp_buf[2] = fxh_get() & 0xf0	# CH2 vol
			temp_buf[3] = fxh_get()	# CH2 duty
			temp_buf[4] = fxh_get()	# CH2 note
			temp_buf[5] = fxh_get()	# CH4 pan
			temp_buf[6] = fxh_get()	# CH4 vol
			temp_buf[7] = fxh_get()	# CH4 freq
			fxh_len += 1
		else:
			break # Got to the end of the SFX, break out of the read loop
		
		# Length			Necessary
		bufadd(temp_buf[0] - 1)

		# Frame pan			Necessary
		pan = temp_buf[1] | temp_buf[5]
		if not args.fxinv:
			pan = swapbits(pan, 7, 3)
			pan = swapbits(pan, 5, 1)
		bufadd(pan) # NR51 values

		# CH2 Duty (NR21)
		if fxh_chu & 128:
			bufadd(temp_buf[3])

		# Frame Volume		Necessary
		bufadd(temp_buf[2] | (temp_buf[6] >> 4))

		# CH2 Frequency (NR23)
		if fxh_chu & 128:
			bufadd(CH2freqs[(temp_buf[4] - 0x40) >> 1] & 0xff)

		# CH2 Frequency higher 3 bits (NR24)
		if fxh_chu & 128:
			bufadd(CH2freqs[(temp_buf[4] - 0x40) >> 1] >> 8 | 0x80) # Note index - 0x40 / 2 >> 8 | trigger bit

		# CH4 Freq (NR43)
		if fxh_chu & 32:
			bufadd(temp_buf[7])

	filename = "SFX_" + (("{0:X}").format(fxnum)).zfill(2)

	def c_header():
		return """/*

		""" + filename + """

		Sound Effect File.
		
		Info:
			Length			:	""" + str(fxh_len) + """
			Priority		:	""" + str(fxh_pry) + """
			Channels used	:	""" + ch_used_str[fxh_chu] + """
		
		This file was generated by hammer2cbt

	*/
	"""

	# Write to C file
	if args.out == ".":
		args.out = ""
	Cfile = open(args.out + filename + ".c", "w")
	Cfile.write(c_header())
	Cfile.write("const unsigned char " + filename + "[] = {\n")
	Cfile.write(str(fxh_chu | fxh_pry) + ", // Header\n")
	Cfile.write(str(fxh_len) + ",\n")
	Cfile.write(str(fxh_buf)[1:-1])
	Cfile.write("\n};")
	Cfile.close()

	Hfile = open(args.out + filename + ".h", "w")
	Hfile.write(c_header())
	Hfile.write("#ifndef __" + filename + "_h_INCLUDE\n")
	Hfile.write("#define __" + filename + "_h_INCLUDE\n")
	Hfile.write("#define CBTFX_PLAY_" + filename + " CBTFX_init(&" + filename + "[0])\n")
	Hfile.write("extern const unsigned char " + filename + "[];\n")
	Hfile.write("#endif")
	Hfile.close()

	print(filename + ".c" + " succesfully written.")
	print(filename + " Size: " + str(len(fxh_buf) + 2) + " bytes.")
